<!DOCTYPE html>
<html lang="zh"
  x-data
  :class="$store.darkMode.class()"
  :data-theme="$store.darkMode.theme()">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS144-计算机网络笔记（lab 0 - 4 ) | Ar-Gas&#39;blog</title>

    
  
    <link href="/favicon.ico" rel="icon" type="image/x-icon" />
  


<link rel="canonical" href="http://localhost:1313/past_posts/cs144%E7%AC%94%E8%AE%B0/" />



<meta name="author" content="Ar-Gas" />
<meta name="description" content="Ar-Gas的思考" />



<meta name="generator" content="Hugo 0.143.1">


<meta property="og:url" content="http://localhost:1313/past_posts/cs144%E7%AC%94%E8%AE%B0/">
  <meta property="og:site_name" content="Ar-Gas&#39;blog">
  <meta property="og:title" content="CS144-计算机网络笔记（lab 0 - 4 )">
  <meta property="og:description" content="最近闲来无事（犯懒），把CS144的lab记一下（目前lab4待调试，但是时间被占用了，后面看情况填坑吧QAQ）
前置知识建议学下MIT6.081，good to have">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="past_posts">
    <meta property="article:published_time" content="2024-03-30T20:20:00+00:00">
    <meta property="article:modified_time" content="2024-03-30T20:20:00+00:00">
    <meta property="article:tag" content="学习笔记">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="CS144-计算机网络笔记（lab 0 - 4 )">
  <meta name="twitter:description" content="最近闲来无事（犯懒），把CS144的lab记一下（目前lab4待调试，但是时间被占用了，后面看情况填坑吧QAQ）
前置知识建议学下MIT6.081，good to have">




<link rel="stylesheet" href="/css/output.css" />




    


<style>
  pre {
    padding: 1em;
    overflow: auto;
  }
</style>









    

    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  </head>

  <body x-data="{
    flip: false,
  }">
    
    <div id="dream-global-bg"></div>

    
<nav x-data="{ isSticky: false }"
  x-init="window.addEventListener('scroll', () => { isSticky = window.scrollY > 30 })"
  class="sticky top-0 z-30 mt-4 lg:mt-8 py-4"
  :class="{ 'bg-base-100 shadow-lg dark:border-b dark:border-base-content/30': isSticky }">

  
  <div class="container flex justify-between px-4">
  
    <section class="flex items-center gap-4">
      <div class="avatar cursor-pointer hover:online" @click="flip = !flip" title="翻转一下！">
        <div class="h-10 rounded-full">
          <img src="/img/argas.png" alt="Ar-Gas" />
        </div>
      </div>

      
      <div>
        
        <a href="http://localhost:1313/" class="text-lg font-semibold cursor-pointer">
          Ar-Gas
        </a>
        
        
        <div class="text-base-content/60 text-sm">深入，深刻</div>
        
      </div>
      
    </section>

    <div class="dropdown dropdown-end sm:hidden">
      <div tabindex="0" role="button" class="btn btn-ghost btn-square" aria-label="Select an option">
        <ion-icon name="menu" class="text-2xl"></ion-icon>
      </div>
      <ul tabindex="0" class="dropdown-content menu w-36 bg-base-100 rounded-box z-[1] shadow-md">
        


<li>
  <div role="link" tabindex="0" class="inline-flex items-center p-2 cursor-pointer" @click="flip = !flip" title="关于">
    <ion-icon name="information-circle"></ion-icon>关于</div>
</li>























<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/index.xml" title="RSS">
    <ion-icon name="logo-rss"></ion-icon>
    RSS
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/posts" title="归档">
    <ion-icon name="archive"></ion-icon>
    归档
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/categories" title="所有分类">
    <ion-icon name="grid"></ion-icon>
    所有分类
  </a>
</li>




<li>
  <a class="inline-flex items-center p-2 cursor-pointer" href="/tags" title="所有标签">
    <ion-icon name="pricetags"></ion-icon>
    所有标签
  </a>
</li>






      </ul>
    </div>
    <section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4">
      
      
      
      <div role="link" tabindex="0"
        class="text-sm font-semibold cursor-pointer hover:underline"
        @click="flip = !flip"
        title="关于"
      >关于</div>
      
      

      
      
        
      

      

      
      





      
      





      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/index.xml" title="RSS">
  <ion-icon class="group-hover:text-primary-content" name="logo-rss"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/posts" title="归档">
  <ion-icon class="group-hover:text-primary-content" name="archive"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/categories" title="所有分类">
  <ion-icon class="group-hover:text-primary-content" name="grid"></ion-icon>
</a>


      
      
<a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="/tags" title="所有标签">
  <ion-icon class="group-hover:text-primary-content" name="pricetags"></ion-icon>
</a>


      

      

      
    </section>
  </div>
</nav>


    <div class="flip-container" :class="{ 'flip-it': flip }">
      <div class="flipper">
        <div class="front">
          <div class="container">
            
<div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4">
  <div class="hidden lg:block">
    
  </div>

  <div class="lg:col-span-2">
    <article class="mx-auto prose prose-quoteless dark:prose-invert" id="dream-single-post-main" itemscope itemtype="http://schema.org/Article">
      
  <meta itemprop="name" content="CS144-计算机网络笔记（lab 0 - 4 )">
  <meta itemprop="description" content="最近闲来无事（犯懒），把CS144的lab记一下（目前lab4待调试，但是时间被占用了，后面看情况填坑吧QAQ）
前置知识建议学下MIT6.081，good to have">
  <meta itemprop="datePublished" content="2024-03-30T20:20:00+00:00">
  <meta itemprop="dateModified" content="2024-03-30T20:20:00+00:00">
  <meta itemprop="wordCount" content="3572">
  <meta itemprop="keywords" content="学习笔记">

      <header>
        <h1 itemprop="headline">CS144-计算机网络笔记（lab 0 - 4 )</h1>
        <p class="text-sm">
          
            <span data-format="luxon">2024-03-30T20:20:00Z</span>
          

          | <span>17分钟阅读</span>

          
          | <span>更新于
            
              <span data-format="luxon">2024-03-30T20:20:00Z</span>
            </span>
          
        </p>

        
        <div class="flex justify-between">
          
            <div class="flex items-center">
  
  <span>@</span>
  

  <span itemprop="author" itemscope itemtype="https://schema.org/Person">
  
    <span itemprop="name">Ar-Gas</span>
  
  </span>
</div>

          

          <div class="flex items-center gap-2">
  
  

  
  
  
  
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://x.com/intent/post?text=CS144-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%ac%94%e8%ae%b0%ef%bc%88lab%200%20-%204%20%29&amp;url=http://localhost:1313/past_posts/cs144%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener noreferrer"
      title="Share on X">
      <ion-icon class="group-hover:text-primary-content" name="logo-x"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://facebook.com/sharer/sharer.php?u=http://localhost:1313/past_posts/cs144%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener noreferrer"
      title="Share on Facebook">
      <ion-icon class="group-hover:text-primary-content" name="logo-facebook"></ion-icon>
    </a>
  
    <a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary"
      href="https://wa.me/?text=CS144-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%ac%94%e8%ae%b0%ef%bc%88lab%200%20-%204%20%29%20http://localhost:1313/past_posts/cs144%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener noreferrer"
      title="Share on WhatsApp">
      <ion-icon class="group-hover:text-primary-content" name="logo-whatsapp"></ion-icon>
    </a>
  

  
  
</div>

        </div>
      </header>

      <section id="dream-single-post-content" itemprop="articleBody">
        

        <p>最近闲来无事（<del>犯懒</del>），把CS144的lab记一下（目前lab4待调试，但是时间被占用了，后面看情况填坑吧QAQ）</p>
<p>前置知识建议学下MIT6.081，good to have</p>
<h1 id="lab0">lab0</h1>
<p>lab0主要是环境配置和热身，我这里使用的是Ubuntu20的系统，由于CS144先前的版本已经从Github删除，使用的是<a href="https://gitee.com/kangyupl/sponge" target="_blank">Kangyupl的存档</a>
，配置教程可以参考：<a href="https://doraemonzzz.com/2021/12/12/2021-12-12-CS144-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#%E8%B0%83%E8%AF%95" target="_blank">CS144 实验环境配置</a>
，编译也可以看<a href="https://doraemonzzz.com/tags/CS144/" target="_blank">Doraemonzzz</a>
的整理</p>
<h3 id="webgetcc">webget.cc</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_URL</span>(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>host, <span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>path) {
</span></span><span style="display:flex;"><span>    TCPSocket sock{};
</span></span><span style="display:flex;"><span>    sock.connect(Address(host,<span style="color:#e6db74">&#34;http&#34;</span>));
</span></span><span style="display:flex;"><span>    sock.write(<span style="color:#e6db74">&#34;GET &#34;</span><span style="color:#f92672">+</span>path<span style="color:#f92672">+</span><span style="color:#e6db74">&#34; HTTP/1.1</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">Host: &#34;</span><span style="color:#f92672">+</span>host<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n\r\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    sock.shutdown(SHUT_WR);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>sock.eof()){
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span>sock.read();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sock.close();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            abort();  <span style="color:#75715e">// For sticklers: don&#39;t try to access argv[0] if argc &lt;= 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The program takes two command-line arguments: the hostname and &#34;path&#34; part of the URL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Print the usage message unless there are these two arguments (plus the program name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// itself, so arg count = 3 in total).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>            cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Usage: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> argv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; HOST PATH</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Example: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> argv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; stanford.edu /class/cs144</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Get the command-line arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> string host <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> string path <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Call the student-written function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        get_URL(host, path);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#66d9ef">const</span> exception <span style="color:#f92672">&amp;</span>e) {
</span></span><span style="display:flex;"><span>        cerr <span style="color:#f92672">&lt;&lt;</span> e.what() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="byte_streamhh">byte_stream.hh</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#ifndef SPONGE_LIBSPONGE_BYTE_STREAM_HH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SPONGE_LIBSPONGE_BYTE_STREAM_HH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;util/buffer.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstddef&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdint&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \brief An in-order byte stream.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! Bytes are written on the &#34;input&#34; side and read from the &#34;output&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! side.  The byte stream is finite: the writer can end the input,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! and then no more bytes can be written.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ByteStream</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Your code here -- add private members as necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BufferList _buffer <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>    size_t _capacity <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    size_t _read_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    size_t _write_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> _input_ended_flag <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> _error <span style="color:#f92672">=</span> false;  <span style="color:#75715e">//!&lt; Flag indicating that the stream suffered an error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Construct a stream with room for `capacity` bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ByteStream(<span style="color:#66d9ef">const</span> size_t capacity);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name &#34;Input&#34; interface for the writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Write a string of bytes into the stream. Write as many
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! as will fit, and return how many were written.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \returns the number of bytes accepted into the stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \returns the number of additional bytes that the stream has space for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">remaining_capacity</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Signal that the byte stream has reached its ending
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">end_input</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Indicate that the stream suffered an error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_error</span>() { _error <span style="color:#f92672">=</span> true; }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name &#34;Output&#34; interface for the reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Peek at next &#34;len&#34; bytes of the stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \returns a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>string peek_output(<span style="color:#66d9ef">const</span> size_t len) <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Remove bytes from the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop_output</span>(<span style="color:#66d9ef">const</span> size_t len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Read (i.e., copy and then pop) the next &#34;len&#34; bytes of the stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \returns a vector of bytes read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>string read(<span style="color:#66d9ef">const</span> size_t len) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> ret <span style="color:#f92672">=</span> peek_output(len);
</span></span><span style="display:flex;"><span>        pop_output(len);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \returns `true` if the stream input has ended
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">input_ended</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \returns `true` if the stream has suffered an error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">error</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _error; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \returns the maximum amount that can currently be read from the stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">buffer_size</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \returns `true` if the buffer is empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">buffer_empty</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \returns `true` if the output has reached the ending
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">eof</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//  ! \name General accounting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Total number of bytes written
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">bytes_written</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Total number of bytes popped
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">bytes_read</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// SPONGE_LIBSPONGE_BYTE_STREAM_HH
</span></span></span></code></pre></div><h3 id="byte_streamcc">byte_stream.cc</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;byte_stream.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdexcept&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dummy implementation of a flow-controlled in-memory byte stream.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For Lab 0, please replace with a real implementation that passes the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// automated checks run by `make check_lab0`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// You will need to add private members to the class declaration in `byte_stream.hh`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Targs<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> DUMMY_CODE(Targs <span style="color:#f92672">&amp;&amp;</span>... <span style="color:#75715e">/* unused */</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ByteStream<span style="color:#f92672">::</span>ByteStream(<span style="color:#66d9ef">const</span> size_t capacity) <span style="color:#f92672">:</span> _capacity(capacity) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t ByteStream<span style="color:#f92672">::</span>write(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>data) {
</span></span><span style="display:flex;"><span>    size_t len <span style="color:#f92672">=</span> data.length();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">&gt;</span> _capacity <span style="color:#f92672">-</span> _buffer.size()) {
</span></span><span style="display:flex;"><span>        len <span style="color:#f92672">=</span> _capacity <span style="color:#f92672">-</span> _buffer.size();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _write_count <span style="color:#f92672">+=</span> len;
</span></span><span style="display:flex;"><span>    string s;
</span></span><span style="display:flex;"><span>    s.assign(data.begin(), data.begin() <span style="color:#f92672">+</span> len);
</span></span><span style="display:flex;"><span>    _buffer.append(BufferList(move(s)));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param[in] len bytes will be copied from the output side of the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>string ByteStream<span style="color:#f92672">::</span>peek_output(<span style="color:#66d9ef">const</span> size_t len) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    size_t length <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (length <span style="color:#f92672">&gt;</span> _buffer.size()) {
</span></span><span style="display:flex;"><span>        length <span style="color:#f92672">=</span> _buffer.size();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    string s <span style="color:#f92672">=</span> _buffer.concatenate();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">string</span>().assign(s.begin(), s.begin() <span style="color:#f92672">+</span> length);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param[in] len bytes will be removed from the output side of the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> ByteStream<span style="color:#f92672">::</span>pop_output(<span style="color:#66d9ef">const</span> size_t len) {
</span></span><span style="display:flex;"><span>    size_t length <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (length <span style="color:#f92672">&gt;</span> _buffer.size()) {
</span></span><span style="display:flex;"><span>        length <span style="color:#f92672">=</span> _buffer.size();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _read_count <span style="color:#f92672">+=</span> length;
</span></span><span style="display:flex;"><span>    _buffer.remove_prefix(length);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> ByteStream<span style="color:#f92672">::</span>end_input() { _input_ended_flag <span style="color:#f92672">=</span> true; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ByteStream<span style="color:#f92672">::</span>input_ended() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _input_ended_flag; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t ByteStream<span style="color:#f92672">::</span>buffer_size() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _buffer.size(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ByteStream<span style="color:#f92672">::</span>buffer_empty() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _buffer.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> ByteStream<span style="color:#f92672">::</span>eof() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">buffer_empty</span>() <span style="color:#f92672">&amp;&amp;</span> input_ended(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t ByteStream<span style="color:#f92672">::</span>bytes_written() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _write_count; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t ByteStream<span style="color:#f92672">::</span>bytes_read() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _read_count; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t ByteStream<span style="color:#f92672">::</span>remaining_capacity() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _capacity <span style="color:#f92672">-</span> _buffer.size(); }
</span></span></code></pre></div><h1 id="lab1">lab1</h1>
<h2 id="配置">配置</h2>
<p>其他lab同理</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git checkout -b lab1-startercode
</span></span><span style="display:flex;"><span>git fetch
</span></span><span style="display:flex;"><span>git merge origin/lab1-startercode
</span></span><span style="display:flex;"><span>cd build
</span></span><span style="display:flex;"><span>make -j4 <span style="color:#f92672">&amp;&amp;</span> make check_lab1
</span></span></code></pre></div><h2 id="实验结构">实验结构</h2>
<p>这幅图完整的说明了CS144 这门实验的结构：</p>
<p><img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20211105142904316.png" alt="CS144"></p>
<p>其中， <code>ByteStream</code> 是我们已经在 Lab0 中实现完成的。</p>
<p>我们将在接下来的实验中分别实现：</p>
<ul>
<li>Lab1 <code>StreamReassembler</code>：实现一个流重组器，一个将字节流的字串或者小段按照正确顺序来拼接回连续字节流的模块</li>
<li>Lab2 <code>TCPReceiver</code>：实现入站字节流的TCP部分：这涉及到考虑 TCP 如何表示流中每个字节的位置（称为“序列号”）。 TCPReceiver 负责告诉发送方 (a) 它已经能够成功组装多少入站字节流（这称为“确认”）以及 (b) 发送方现在还可以发送多少字节（“流量控制”）。</li>
<li>Lab3 <code>TCPSender</code>：实现出站字节流的TCP部分：当发送方怀疑其传输的数据段在传输过程中丢失并且从未到达接收方时，应该如何反应？什么时候应该重试并重新传输丢失的分段？</li>
<li>Lab4 <code>TCPConnection</code>: 结合之前的工作来创建一个有效的 TCP 实现。最后我们可以使用这个 TCP 实现来和真实世界的服务器进行通信。</li>
</ul>



  <blockquote>
    <p>该实验引导我们以模块化的方式构建一个 TCP 实现。</p>
  </blockquote>

<p>流重组器在 TCP 起到了相当重要的作用。迫于网络环境的限制，TCP 发送者会将数据切割成一个个小段的数据分批发送。但这就可能带来一些新的问题：数据在网络中传输时可能丢失、重排、多次重传等等。而TCP接收者就必须通过流重组器，将接收到的<strong>这些重排重传等等的数据包</strong>重新组装成新的连续字节流。</p>
<p><img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20211107124153476.png" alt="流重组器"></p>
<h2 id="环境配置">环境配置</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://gitee.com/kangyupl/sponge
</span></span><span style="display:flex;"><span>git checkout -b lab1-startercode origin/lab1-startercode
</span></span><span style="display:flex;"><span>mkdir build <span style="color:#f92672">&amp;&amp;</span> cd build
</span></span><span style="display:flex;"><span>cmake ..
</span></span><span style="display:flex;"><span>make format
</span></span><span style="display:flex;"><span>make -j4 <span style="color:#f92672">&amp;&amp;</span> make check_lab1 
</span></span></code></pre></div><h2 id="接口">接口</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// Construct a `StreamReassembler` that will store up to `capacity` bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 构造一个“StreamReassembler”，最多可存储“capacity”字节。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>StreamReassembler(<span style="color:#66d9ef">const</span> size_t capacity);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Receive a substring and write any newly contiguous bytes into the stream,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// while staying within the memory limits of the `capacity`. Bytes that would
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// exceed the capacity are silently discarded.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `data`: the substring
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `index` indicates the index (place in sequence) of the first byte in `data`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `eof`: the last byte of this substring will be the last byte in the entire stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 接收子字符串并将任何新的连续字节写入流中， 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 同时保持在“容量”的内存限制内。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 超出容量的字节将被默默丢弃。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `data`：子字符串 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `index` 表示 `data` 中第一个字节的索引（按顺序排列） 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `eof`：该子字符串的最后一个字节将是该子字符串中的最后一个字节整个流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_substring</span>(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>data, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> index, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> eof);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Access the reassembled ByteStream (your code from Lab 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问重新组装的字节流（来自lab 0 的代码）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ByteStream <span style="color:#f92672">&amp;</span>stream_out();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The number of bytes in the substrings stored but not yet reassembled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 已存储但尚未重组的子字符串中的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>size_t <span style="color:#a6e22e">unassembled_bytes</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Is the internal state empty (other than the output stream)?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 内部状态是否为空（除了输出流）？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span>;
</span></span></code></pre></div><h2 id="streamreassembler实现">StreamReassembler实现</h2>
<p>自己写的过不了（，这里参考<a href="https://github.com/huangrt01/TCP-Lab/tree/master" target="_blank">@huangrt01</a>
</p>
<h3 id="stream_reassemblerhh">stream_reassembler.hh</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//! \brief type of unassembled elm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">typeUnassembled</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>	
</span></span><span style="display:flex;"><span>    size_t _index;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string _data;
</span></span><span style="display:flex;"><span>    typeUnassembled(size_t index, std<span style="color:#f92672">::</span>string data) <span style="color:#f92672">:</span> _index(index), _data(data){};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span>(typeUnassembled t)<span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> _index <span style="color:#f92672">&lt;</span> t._index;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \brief A class that assembles a series of excerpts from a byte stream (possibly out of order,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! possibly overlapping) into an in-order byte stream.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StreamReassembler</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Your code here -- add private members as necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/// @brief 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>typeUnassembled<span style="color:#f92672">&gt;</span> _Unassembled;
</span></span><span style="display:flex;"><span>    size_t _firstUnassembled;
</span></span><span style="display:flex;"><span>    size_t _nUnassembled;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> _eof;
</span></span><span style="display:flex;"><span>    ByteStream _output;  <span style="color:#75715e">//!&lt; The reassembled in-order byte stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t _capacity;    <span style="color:#75715e">//!&lt; The maximum number of bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">merge_substring</span>(size_t <span style="color:#f92672">&amp;</span> index, std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data, size_t index2, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data2);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Construct a `StreamReassembler` that will store up to `capacity` bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \note This capacity limits both the bytes that have been reassembled,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! and those that have not yet been reassembled.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    StreamReassembler(<span style="color:#66d9ef">const</span> size_t capacity);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Receives a substring and writes any newly contiguous bytes into the stream.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! If accepting all the data would overflow the `capacity` of this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! `StreamReassembler`, then only the part of the data that fits will be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! accepted. If the substring is only partially accepted, then the `eof`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! will be disregarded.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \param data the string being added
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \param index the index of the first byte in `data`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \param eof whether or not this segment ends with the end of the stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_substring</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> index, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> eof);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name Access the reassembled byte stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> ByteStream <span style="color:#f92672">&amp;</span>stream_out() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _output; }
</span></span><span style="display:flex;"><span>    ByteStream <span style="color:#f92672">&amp;</span>stream_out() { <span style="color:#66d9ef">return</span> _output; }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! The number of bytes in the substrings stored but not yet reassembled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \note If the byte at a particular index has been submitted twice, it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! should only be counted once for the purpose of this function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">unassembled_bytes</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Is the internal state empty (other than the output stream)?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \returns `true` if no substrings are waiting to be assembled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH
</span></span></span></code></pre></div><h3 id="stream_reassemblercc">stream_reassembler.cc</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>StreamReassembler<span style="color:#f92672">::</span>StreamReassembler(<span style="color:#66d9ef">const</span> size_t capacity) <span style="color:#f92672">:</span> _Unassembled(), _firstUnassembled(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>                                     _nUnassembled(<span style="color:#ae81ff">0</span>), _eof(<span style="color:#ae81ff">0</span>), _output(capacity), _capacity(capacity){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \details This function accepts a substring (aka a segment) of bytes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! possibly out-of-order, from the logical stream, and assembles any newly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! contiguous substrings and writes them into the output stream in order.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> StreamReassembler<span style="color:#f92672">::</span>push_substring(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> index, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> eof){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// discard or not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(data.empty() <span style="color:#f92672">||</span> index <span style="color:#f92672">+</span> data.size() <span style="color:#f92672">&lt;=</span> _firstUnassembled){
</span></span><span style="display:flex;"><span>        _eof <span style="color:#f92672">=</span> _eof <span style="color:#f92672">|</span> eof;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (empty() <span style="color:#f92672">&amp;&amp;</span> _eof){
</span></span><span style="display:flex;"><span>            _output.end_input();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// max of capacity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t firstUnacceptbled <span style="color:#f92672">=</span> _firstUnassembled <span style="color:#f92672">+</span> _capacity <span style="color:#f92672">-</span> _output.buffer_size(); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// optimization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t resIndex <span style="color:#f92672">=</span> index;
</span></span><span style="display:flex;"><span>    size_t beginIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    size_t endIndex <span style="color:#f92672">=</span> data.size();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the redundant ones in front
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&lt;</span> _firstUnassembled){
</span></span><span style="display:flex;"><span>        resIndex <span style="color:#f92672">=</span> _firstUnassembled;
</span></span><span style="display:flex;"><span>        beginIndex <span style="color:#f92672">=</span> _firstUnassembled <span style="color:#f92672">-</span> index;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the redundant ones in back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">+</span> data.size() <span style="color:#f92672">&gt;=</span> firstUnacceptbled) {
</span></span><span style="display:flex;"><span>        endIndex <span style="color:#f92672">=</span> firstUnacceptbled <span style="color:#f92672">-</span> index;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> resData <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>string(data.begin() <span style="color:#f92672">+</span> beginIndex, data.begin() <span style="color:#f92672">+</span> endIndex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Merge with front part
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//           | resData |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//         &lt;----|iter|
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> _Unassembled.lower_bound(typeUnassembled(resIndex, <span style="color:#e6db74">&#34;&#34;</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (iter <span style="color:#f92672">!=</span> _Unassembled.begin()){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// resIndex &gt; _firstUnassembled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (iter <span style="color:#f92672">==</span> _Unassembled.end()){
</span></span><span style="display:flex;"><span>            iter<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (size_t deleteNum <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>                merge_substring(resIndex, resData, (<span style="color:#f92672">*</span>iter)._index, (<span style="color:#f92672">*</span>iter)._data)){
</span></span><span style="display:flex;"><span>                    _nUnassembled <span style="color:#f92672">-=</span> deleteNum;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (iter <span style="color:#f92672">!=</span> _Unassembled.begin()){
</span></span><span style="display:flex;"><span>                        _Unassembled.erase(iter<span style="color:#f92672">--</span>);
</span></span><span style="display:flex;"><span>                    }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        _Unassembled.erase(iter);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }           
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Merge with back part
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//         ｜resData |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//          | iter ... | ---&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    iter <span style="color:#f92672">=</span> _Unassembled.lower_bound(typeUnassembled(resIndex, <span style="color:#e6db74">&#34;&#34;</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (iter <span style="color:#f92672">!=</span> _Unassembled.end()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (size_t deleteNum <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                   merge_substring(resIndex, resData, (<span style="color:#f92672">*</span>iter)._index, (<span style="color:#f92672">*</span>iter)._data)){
</span></span><span style="display:flex;"><span>                        _Unassembled.erase(iter<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>                        _nUnassembled <span style="color:#f92672">-=</span> deleteNum;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (resIndex <span style="color:#f92672">==</span> _firstUnassembled) {
</span></span><span style="display:flex;"><span>        size_t wSize <span style="color:#f92672">=</span> _output.write(resData);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((wSize <span style="color:#f92672">==</span> resData.size()) <span style="color:#f92672">&amp;&amp;</span> eof){
</span></span><span style="display:flex;"><span>            _eof <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            _output.end_input();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        _firstUnassembled <span style="color:#f92672">+=</span> wSize;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// eof
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (resData.empty()){
</span></span><span style="display:flex;"><span>        _eof <span style="color:#f92672">=</span> _eof <span style="color:#f92672">|</span> eof;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (resIndex <span style="color:#f92672">&gt;</span> _firstUnassembled) {
</span></span><span style="display:flex;"><span>        _eof <span style="color:#f92672">=</span> _eof <span style="color:#f92672">|</span> eof;
</span></span><span style="display:flex;"><span>        _Unassembled.insert(typeUnassembled(resIndex, resData));
</span></span><span style="display:flex;"><span>        _nUnassembled <span style="color:#f92672">+=</span> resData.size();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (empty() <span style="color:#f92672">&amp;&amp;</span> _eof) {
</span></span><span style="display:flex;"><span>        _output.end_input();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> StreamReassembler<span style="color:#f92672">::</span>merge_substring(size_t <span style="color:#f92672">&amp;</span>index, std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data, size_t index2, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>data2) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// return value:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// &gt; 0: successfully merge, return the overlapped size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0: fail to merge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t l1 <span style="color:#f92672">=</span> index, r1 <span style="color:#f92672">=</span> l1 <span style="color:#f92672">+</span> data.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    size_t l2 <span style="color:#f92672">=</span> index2, r2 <span style="color:#f92672">=</span> l2 <span style="color:#f92672">+</span> data2.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (l2 <span style="color:#f92672">&gt;</span> r1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> l1 <span style="color:#f92672">&gt;</span> r2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    index <span style="color:#f92672">=</span> min(l1, l2);
</span></span><span style="display:flex;"><span>    size_t deleteNum <span style="color:#f92672">=</span> data2.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (l1 <span style="color:#f92672">&lt;=</span> l2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (r2 <span style="color:#f92672">&gt;</span> r1) {
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">+=</span> std<span style="color:#f92672">::</span>string(data2.begin() <span style="color:#f92672">+</span> r1 <span style="color:#f92672">-</span> l2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, data2.end());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (r1 <span style="color:#f92672">&gt;</span> r2) {
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> data2 <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>string(data.begin() <span style="color:#f92672">+</span> r2 <span style="color:#f92672">-</span> l1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, data.end());
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> data2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> deleteNum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t StreamReassembler<span style="color:#f92672">::</span>unassembled_bytes() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _nUnassembled; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> StreamReassembler<span style="color:#f92672">::</span>empty() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _nUnassembled <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
</span></span></code></pre></div><h1 id="lab2">lab2</h1>
<h2 id="序列号转换">序列号转换</h2>
<p>WrappingInt32包装了一个无符号32位（循环序号）转无符号64位的方法，转换中用checkpoint做判断避免一对多</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 随机的isn + 转为32位的n绝对序列号（从0开始）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>WrappingInt32 <span style="color:#a6e22e">wrap</span>(<span style="color:#66d9ef">uint64_t</span> n, WrappingInt32 isn) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> WrappingInt32{isn <span style="color:#f92672">+</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span>(n)};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint64_t</span> <span style="color:#a6e22e">unwrap</span>(WrappingInt32 n, WrappingInt32 isn, <span style="color:#66d9ef">uint64_t</span> checkpoint) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> offset <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> wrap(checkpoint, isn);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> ret <span style="color:#f92672">=</span> checkpoint <span style="color:#f92672">+</span> offset;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 取距离checkpoint最近的值，因此需要判断是否左移ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意位置不够左移的情形！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">&gt;=</span> (<span style="color:#ae81ff">1u</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">31</span>) <span style="color:#f92672">&amp;&amp;</span> ret <span style="color:#f92672">&gt;=</span> (<span style="color:#ae81ff">1ul</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span>)) {<span style="color:#75715e">//确保在无符号32位整数的范围内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ret <span style="color:#f92672">-=</span> (<span style="color:#ae81ff">1ul</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="tcpreceiver">TCPReceiver</h2>
<p><img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/%E5%9B%BE%E5%83%8F9.png" alt="TCP报文结构"></p>
<p><img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20211107122822566.png" alt="image-20211107122822566"></p>
<p>对于 TCPReceiver 来说，除了错误状态以外，它一共有3种状态，分别是：</p>
<ul>
<li>LISTEN：等待 SYN 包的到来。若在 SYN 包到来前就有其他数据到来，则<strong>必须丢弃</strong>。</li>
<li>SYN_RECV：获取到了 SYN 包，此时可以正常的接收数据包</li>
<li>FIN_RECV：获取到了 FIN 包，此时务必终止 ByteStream 数据流的输入。</li>
</ul>
<p>在每次 TCPReceiver 接收到数据包时，我们该如何知道当前接收者处于什么状态呢？可以通过以下方式快速判断：</p>
<ul>
<li>当 isn 还没设置时，肯定是 LISTEN 状态</li>
<li>当 ByteStream.input_ended()，则肯定是 FIN_RECV 状态</li>
<li>其他情况下，是 SYN_RECV 状态</li>
</ul>
<p>tcp_receiver.hh</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TCPReceiver</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Our data structure for re-assembling bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    StreamReassembler _reassembler;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> _syn_received;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> _fin_received;
</span></span><span style="display:flex;"><span>    WrappingInt32 _isn;
</span></span><span style="display:flex;"><span>    WrappingInt32 _ackno;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> _checkpoint;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! The maximum number of bytes we&#39;ll store.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t _capacity;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Construct a TCP receiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \param capacity the maximum number of bytes that the receiver will
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!                 store in its buffers at any give time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TCPReceiver(<span style="color:#66d9ef">const</span> size_t capacity)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> _reassembler(capacity), _syn_received(<span style="color:#ae81ff">0</span>), _fin_received(<span style="color:#ae81ff">0</span>), _isn(<span style="color:#ae81ff">0</span>), _ackno(<span style="color:#ae81ff">0</span>), _checkpoint(<span style="color:#ae81ff">0</span>) {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>tcp_receiver.cc</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> TCPReceiver<span style="color:#f92672">::</span>segment_received(<span style="color:#66d9ef">const</span> TCPSegment <span style="color:#f92672">&amp;</span>seg) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> old_syn_received <span style="color:#f92672">=</span> _syn_received, old_fin_received <span style="color:#f92672">=</span> _fin_received;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> TCPHeader <span style="color:#f92672">&amp;</span>hdr <span style="color:#f92672">=</span> seg.header();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>hdr.syn <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>_syn_received){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_reassembler.eof() <span style="color:#f92672">&amp;&amp;</span> hdr.fin){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_syn_received){
</span></span><span style="display:flex;"><span>        _isn <span style="color:#f92672">=</span> hdr.seqno;
</span></span><span style="display:flex;"><span>        _syn_received <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> win_start <span style="color:#f92672">=</span> unwrap(<span style="color:#f92672">*</span>ackno(), _isn, _checkpoint);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> win_size <span style="color:#f92672">=</span> window_size() <span style="color:#f92672">?</span> window_size() <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> win_end <span style="color:#f92672">=</span> win_start <span style="color:#f92672">+</span> win_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> seq_start <span style="color:#f92672">=</span> unwrap(hdr.seqno, _isn, _checkpoint);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> seq_size <span style="color:#f92672">=</span> seg.length_in_sequence_space();
</span></span><span style="display:flex;"><span>    seq_size <span style="color:#f92672">=</span> (seq_size) <span style="color:#f92672">?</span> seq_size : <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> seq_end <span style="color:#f92672">=</span> seq_start <span style="color:#f92672">+</span> seq_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> payload_size <span style="color:#f92672">=</span> seg.payload().size();
</span></span><span style="display:flex;"><span>    payload_size <span style="color:#f92672">=</span> (payload_size) <span style="color:#f92672">?</span> payload_size : <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> payload_end <span style="color:#f92672">=</span> seq_start <span style="color:#f92672">+</span> payload_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> inbound <span style="color:#f92672">=</span> (seq_start <span style="color:#f92672">&gt;=</span> win_start <span style="color:#f92672">&amp;&amp;</span> seq_start <span style="color:#f92672">&lt;=</span> win_end) <span style="color:#f92672">||</span> (payload_end <span style="color:#f92672">&gt;=</span> win_start <span style="color:#f92672">&amp;&amp;</span> seq_end <span style="color:#f92672">&lt;=</span> win_end);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (inbound){
</span></span><span style="display:flex;"><span>        _reassembler.push_substring(seg.payload().copy(), seq_start <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, hdr.fin);  <span style="color:#75715e">//忽视syn，所以减1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _checkpoint <span style="color:#f92672">=</span> _reassembler.unassembled_bytes();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hdr.fin <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>_fin_received) {
</span></span><span style="display:flex;"><span>        _fin_received <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// if flags = SF and payload_size = 0, we need to end_input() the stream manually
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (hdr.syn <span style="color:#f92672">&amp;&amp;</span> seg.length_in_sequence_space() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>            stream_out().end_input();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> fin_finished <span style="color:#f92672">=</span> _fin_received <span style="color:#f92672">&amp;&amp;</span> (_reassembler.unassembled_bytes() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    _ackno <span style="color:#f92672">=</span> wrap(_reassembler.unassembled_bytes() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> fin_finished, _isn);  <span style="color:#75715e">//+1因为bytestream不给syn标号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// second syn or fin will be rejected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((inbound) <span style="color:#f92672">||</span> (hdr.fin <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>old_fin_received) <span style="color:#f92672">||</span> (hdr.syn <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>old_syn_received)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>optional<span style="color:#f92672">&lt;</span>WrappingInt32<span style="color:#f92672">&gt;</span> TCPReceiver<span style="color:#f92672">::</span>ackno() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_syn_received) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> nullopt;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {_ackno};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t TCPReceiver<span style="color:#f92672">::</span>window_size() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">stream_out</span>().remaining_capacity(); }
</span></span></code></pre></div><h1 id="lab3">lab3</h1>
<h2 id="tcpsender">TCPsender</h2>
<p><img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/eb8abd73-a0e0-4310-a59f-17b5505114f6.png" alt="TCPsender"></p>
<h3 id="1tcpsender-功能">1.TCPSender 功能</h3>
<p>TCP Sender 负责</p>
<h3 id="2-如何检测丢包">2. 如何检测丢包</h3>
<p>TCP 使用<strong>超时重传机制</strong>。TCPSender 除了将原始数据流分解成众多 TCP 报文并发送以外，它还会追踪每个<strong>已发送报文</strong>（已被发送但还未被接收）的发送时间。如果某些<strong>已发送报文</strong>太久没有被接收方确认（即接收方接收到对应的 ackno），则该数据包必须<strong>重传</strong>。</p>
<p>需要注意的是，<strong>接收方返回的 ackno 并不一定对应着发送方返回的 seqno</strong>（也不和 seqno 有算数关系），这是因为发送的数据可能会因为内存问题，被接收方截断。</p>
<p>接收方确认某个报文，指的是该报文的<strong>所有字节索引</strong>都已被确认。这意味着如果该报文只有<strong>部分被确认</strong>，则不能说明该报文已被完全确认。</p>
<p>TCP 的超时机制比较麻烦，这是因为超时机制直接影响到应用程序从远程服务器上读取数据的响应时间，以及影响到网络拥堵的程度。以下是实现 TCPSender 时需要注意的一些点：</p>
<ul>
<li>
<p>每隔几毫秒，TCPSender的 tick 函数将会被调用，其参数声明了过去的时间。这是 TCPSender 唯一能调用的超时时间相关函数。因为直接调用 clock 或者 time 将会导致测试套件不可用。</p>
</li>
<li>
<p>TCPSender 在构造时会被给予一个<strong>重传超时时间 RTO</strong>的初始值。RTO 是在重新发送未完成 TCP 段之前需要等待的毫秒数。RTO值将会随着时间的流逝（或者更应该说是网络环境的变化）而变化，但<strong>初始的RTO</strong>将始终不变。</p>
</li>
<li>
<p>在 TCPSender 中，我们需要实现一个<strong>重传计时器</strong>。该计时器将会在 RTO 结束时进行一些操作。</p>
</li>
<li>
<p>当每次发送<strong>包含数据</strong>的数据包时，都需要启动重传计时器，并让它在 RTO 毫秒后超时。若所有<strong>发送中报文</strong>均被确认，则终止重传计时器。</p>
</li>
<li>
<p>如果重传计时器超时，则需要进行以下几步（稍微有点麻烦）</p>
<ul>
<li>
<p>重传尚未被 TCP 接收方完全确认的最早报文（即最低 ackno所对应的报文）。这一步需要我们将<strong>发送中的报文数据</strong>保存至一个新的数据结构中，这样才可以追踪正处于发送状态的数据。</p>
</li>
<li>
<p>如果接收者的 window size 不为 0，即可以正常接收数据，则</p>
<ul>
<li>跟踪<strong>连续重传次数</strong>。过多的重传次数可能意味着网络的中断，需要立即停止重传。</li>
<li>将RTO的值设置为先前的两倍，以降低较差网络环境的重传速度，以避免加深网络环境的拥堵。</li>
<li>重置并重启重传计时器。</li>
</ul>



  <blockquote>
    <p><strong>接收者 window size 为 0 的情况</strong>将在下面说明。</p>
  </blockquote>

</li>
</ul>
</li>
<li>
<p>当接收者给发送者一个确认成功接收新数据的 ack 包时（absolute ack seqno 比之前接收到的 ackno 更大）：</p>
<ul>
<li>将 RTO 设置回初始值</li>
<li>如果发送方存在尚未完成的数据，则重新启动重传定时器</li>
<li>将<strong>连续重传计数</strong>清零。</li>
</ul>
</li>
</ul>
<h3 id="代码">代码</h3>
<p>tcp_sender.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#ifndef SPONGE_LIBSPONGE_TCP_SENDER_HH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SPONGE_LIBSPONGE_TCP_SENDER_HH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;byte_stream.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;tcp_config.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;tcp_segment.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;wrapping_integers.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cassert&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \brief The &#34;sender&#34; part of a TCP implementation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! Accepts a ByteStream, divides it up into segments and sends the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! segments, keeps track of which segments are still in-flight,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! maintains the Retransmission Timer, and retransmits in-flight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! segments if the retransmission timer expires.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TCPRetransmissionTimer</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! retransmission timer for the connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> _initial_RTO;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! retransmission timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> _RTO;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> _TO;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! state of the timer, 1:open, 0:close
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> _open;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Initialize a TCP retransmission timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TCPRetransmissionTimer(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint16_t</span> retx_timeout)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> _initial_RTO(retx_timeout), _RTO(retx_timeout), _TO(<span style="color:#ae81ff">0</span>), _open(true) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! state of the timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">open</span>() { <span style="color:#66d9ef">return</span> _open; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! start the timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span>() {
</span></span><span style="display:flex;"><span>        _open <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        _TO <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! close the timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">close</span>() {
</span></span><span style="display:flex;"><span>        _open <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        _TO <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! tick
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">tick</span>(size_t <span style="color:#f92672">&amp;</span>ms_since_last_tick) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>open()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ms_since_last_tick <span style="color:#f92672">&gt;</span> _RTO <span style="color:#f92672">-</span> _TO) {
</span></span><span style="display:flex;"><span>            ms_since_last_tick <span style="color:#f92672">-=</span> (_RTO <span style="color:#f92672">-</span> _TO);
</span></span><span style="display:flex;"><span>            _TO <span style="color:#f92672">=</span> _RTO;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            _TO <span style="color:#f92672">+=</span> ms_since_last_tick;
</span></span><span style="display:flex;"><span>            ms_since_last_tick <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_TO <span style="color:#f92672">&gt;=</span> _RTO) {
</span></span><span style="display:flex;"><span>            _TO <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;  <span style="color:#75715e">// the retransmission timer has expired.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TCPSender</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! our initial sequence number, the number for our SYN.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    WrappingInt32 _isn;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! outbound queue of segments that the TCPSender wants sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>TCPSegment<span style="color:#f92672">&gt;</span> _segments_out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! outstanding segments that the TCPSender may resend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>TCPSegment<span style="color:#f92672">&gt;</span> _segments_outstanding;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! bytes in flight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> _nBytes_inflight;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//！ last ackno
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> _recv_ackno;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! TCP retransmission timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TCPRetransmissionTimer _timer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! notify the window size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span> _window_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! consecutive retransmissions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> _consecutive_retransmissions;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! outgoing stream of bytes that have not yet been sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ByteStream _stream;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! the (absolute) sequence number for the next byte to be sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> _next_seqno;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! the flag of SYN sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> _syn_sent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! the flag of FIN sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> _fin_sent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Generate an non-empty segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">send_non_empty_segment</span>(TCPSegment <span style="color:#f92672">&amp;</span>seg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! Initialize a TCPSender
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TCPSender(<span style="color:#66d9ef">const</span> size_t capacity <span style="color:#f92672">=</span> TCPConfig<span style="color:#f92672">::</span>DEFAULT_CAPACITY,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint16_t</span> retx_timeout <span style="color:#f92672">=</span> TCPConfig<span style="color:#f92672">::</span>TIMEOUT_DFLT,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>WrappingInt32<span style="color:#f92672">&gt;</span> fixed_isn <span style="color:#f92672">=</span> {});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name &#34;Input&#34; interface for the writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ByteStream <span style="color:#f92672">&amp;</span>stream_in() { <span style="color:#66d9ef">return</span> _stream; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> ByteStream <span style="color:#f92672">&amp;</span>stream_in() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _stream; }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name Methods that can cause the TCPSender to send a segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief A new acknowledgment was received
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ack_received</span>(<span style="color:#66d9ef">const</span> WrappingInt32 ackno, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint16_t</span> window_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Generate an empty-payload segment (useful for creating empty ACK segments)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">send_empty_segment</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief create and send segments to fill as much of the window as possible
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fill_window</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Notifies the TCPSender of the passage of time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tick</span>(<span style="color:#66d9ef">const</span> size_t ms_since_last_tick);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name Accessors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief How many sequence numbers are occupied by segments sent but not yet acknowledged?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \note count is in &#34;sequence space,&#34; i.e. SYN and FIN each count for one byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! (see TCPSegment::length_in_sequence_space())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">bytes_in_flight</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief Number of consecutive retransmissions that have occurred in a row
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">consecutive_retransmissions</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief TCPSegments that the TCPSender has enqueued for transmission.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! \note These must be dequeued and sent by the TCPConnection,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! which will need to fill in the fields that are set by the TCPReceiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//! (ackno and window size) before sending.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>TCPSegment<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>segments_out() { <span style="color:#66d9ef">return</span> _segments_out; }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \name What is the next sequence number? (used for testing)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//!@{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief absolute seqno for the next byte to be sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> <span style="color:#a6e22e">next_seqno_absolute</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _next_seqno; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//! \brief relative seqno for the next byte to be sent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    WrappingInt32 <span style="color:#a6e22e">next_seqno</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> wrap(_next_seqno, _isn); }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//!@}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">syn_sent</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _syn_sent; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">fin_sent</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _fin_sent; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// SPONGE_LIBSPONGE_TCP_SENDER_HH
</span></span></span></code></pre></div><p>tcp_sender.cc</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;tcp_sender.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;tcp_config.hh&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dummy implementation of a TCP sender
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For Lab 3, please replace with a real implementation that passes the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// automated checks run by `make check_lab3`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Targs<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> DUMMY_CODE(Targs <span style="color:#f92672">&amp;&amp;</span>... <span style="color:#75715e">/* unused */</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param[in] capacity the capacity of the outgoing byte stream
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TCPSender<span style="color:#f92672">::</span>TCPSender(<span style="color:#66d9ef">const</span> size_t capacity, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint16_t</span> retx_timeout, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>WrappingInt32<span style="color:#f92672">&gt;</span> fixed_isn)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> _isn(fixed_isn.value_or(WrappingInt32{random_device()()}))
</span></span><span style="display:flex;"><span>    , _segments_out{}
</span></span><span style="display:flex;"><span>    , _segments_outstanding{}
</span></span><span style="display:flex;"><span>    , _nBytes_inflight(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    , _recv_ackno(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    , _timer{retx_timeout}
</span></span><span style="display:flex;"><span>    , _window_size(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    , _consecutive_retransmissions{<span style="color:#ae81ff">0</span>}
</span></span><span style="display:flex;"><span>    , _stream(capacity)
</span></span><span style="display:flex;"><span>    , _next_seqno(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    , _syn_sent(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    , _fin_sent(<span style="color:#ae81ff">0</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint64_t</span> TCPSender<span style="color:#f92672">::</span>bytes_in_flight() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _nBytes_inflight; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TCPSender<span style="color:#f92672">::</span>fill_window() {
</span></span><span style="display:flex;"><span>    assert(<span style="color:#f92672">!</span>_stream.error());
</span></span><span style="display:flex;"><span>    TCPSegment seg;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_next_seqno <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// state is CLOSE, need to send SYN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        seg.header().syn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        _syn_sent <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        send_non_empty_segment(seg);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (_next_seqno <span style="color:#f92672">==</span> _nBytes_inflight) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// state is SYN SENT, don&#39;t send SYN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// zero window probing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span> window_size <span style="color:#f92672">=</span> _window_size <span style="color:#f92672">?</span> _window_size : <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> remaining;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((remaining <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint64_t</span><span style="color:#f92672">&gt;</span>(window_size) <span style="color:#f92672">+</span> (_recv_ackno <span style="color:#f92672">-</span> _next_seqno))) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// FIN flag occupies space in window
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        TCPSegment new_seg;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_stream.eof() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>_fin_sent) {
</span></span><span style="display:flex;"><span>            new_seg.header().fin <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            _fin_sent <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            send_non_empty_segment(new_seg);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (_stream.eof()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        size_t size <span style="color:#f92672">=</span> min(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span>(remaining), TCPConfig<span style="color:#f92672">::</span>MAX_PAYLOAD_SIZE);
</span></span><span style="display:flex;"><span>        new_seg.payload() <span style="color:#f92672">=</span> Buffer(_stream.read(size));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (new_seg.length_in_sequence_space() <span style="color:#f92672">&lt;</span> window_size <span style="color:#f92672">&amp;&amp;</span> _stream.eof()) {  <span style="color:#75715e">// piggy-back FIN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            new_seg.header().fin <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            _fin_sent <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (new_seg.length_in_sequence_space() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        send_non_empty_segment(new_seg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param ackno The remote receiver&#39;s ackno (acknowledgment number)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param window_size The remote receiver&#39;s advertised window size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#39;t sent yet)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> TCPSender<span style="color:#f92672">::</span>ack_received(<span style="color:#66d9ef">const</span> WrappingInt32 ackno, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint16_t</span> window_size) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ackno <span style="color:#f92672">-</span> next_seqno() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果window_size为0，需要记录下来，&#34;zero window probing&#34;, 影响tick()和fill_window()的行为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _window_size <span style="color:#f92672">=</span> window_size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> abs_ackno <span style="color:#f92672">=</span> unwrap(ackno, _isn, _recv_ackno);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (abs_ackno <span style="color:#f92672">&lt;=</span> _recv_ackno) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _recv_ackno <span style="color:#f92672">=</span> abs_ackno;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// acknowledges the successful receipt of new data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _timer._RTO <span style="color:#f92672">=</span> _timer._initial_RTO;
</span></span><span style="display:flex;"><span>    _timer._TO <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _consecutive_retransmissions <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// deque fully-acknowledged segments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>_segments_outstanding.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>seg <span style="color:#f92672">=</span> _segments_outstanding.front();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ackno <span style="color:#f92672">-</span> seg.header().seqno <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int32_t</span><span style="color:#f92672">&gt;</span>(seg.length_in_sequence_space())) {
</span></span><span style="display:flex;"><span>            _nBytes_inflight <span style="color:#f92672">-=</span> seg.length_in_sequence_space();
</span></span><span style="display:flex;"><span>            _segments_outstanding.pop();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fill the window
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fill_window();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// any outstanding segment, restart the timer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [RFC6298](5.3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_segments_outstanding.empty()) {
</span></span><span style="display:flex;"><span>        _timer.start();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> TCPSender<span style="color:#f92672">::</span>tick(<span style="color:#66d9ef">const</span> size_t ms_since_last_tick) {
</span></span><span style="display:flex;"><span>    size_t time_left <span style="color:#f92672">=</span> ms_since_last_tick;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_timer.tick(time_left)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Notice: remove fill_the_window() here to fix the test fsm_retx_relaxed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// timer has expired, retransmit at most ONE outstanding segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_segments_outstanding.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// retransmit the outstanding segment with the lowest sequence number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            _segments_out.push(_segments_outstanding.front());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (_window_size) {
</span></span><span style="display:flex;"><span>                _consecutive_retransmissions<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                _timer._RTO <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;  <span style="color:#75715e">// double the RTO, exponential backoff, it slows down retransmissions on lousy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                   <span style="color:#75715e">// networks to avoid further gumming up the works
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_timer.open()) {  <span style="color:#75715e">//[RFC6298](5.1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                _timer.start();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (syn_sent() <span style="color:#f92672">&amp;&amp;</span> (_next_seqno <span style="color:#f92672">==</span> _nBytes_inflight) <span style="color:#f92672">&amp;&amp;</span> (_timer._RTO <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3000</span>)) {
</span></span><span style="display:flex;"><span>                _timer._RTO <span style="color:#f92672">=</span> <span style="color:#ae81ff">3000</span>;  <span style="color:#75715e">// SYN_SENT, [RFC6298](5.7)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_segments_outstanding.empty()) {
</span></span><span style="display:flex;"><span>            _timer.close();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> TCPSender<span style="color:#f92672">::</span>consecutive_retransmissions() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> _consecutive_retransmissions; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TCPSender<span style="color:#f92672">::</span>send_empty_segment() {
</span></span><span style="display:flex;"><span>    TCPSegment seg;
</span></span><span style="display:flex;"><span>    seg.header().seqno <span style="color:#f92672">=</span> wrap(_next_seqno, _isn);
</span></span><span style="display:flex;"><span>    _segments_out.push(seg);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TCPSender<span style="color:#f92672">::</span>send_non_empty_segment(TCPSegment <span style="color:#f92672">&amp;</span>seg) {
</span></span><span style="display:flex;"><span>    seg.header().seqno <span style="color:#f92672">=</span> wrap(_next_seqno, _isn);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _next_seqno <span style="color:#f92672">+=</span> seg.length_in_sequence_space();
</span></span><span style="display:flex;"><span>    _nBytes_inflight <span style="color:#f92672">+=</span> seg.length_in_sequence_space();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// std::cerr &lt;&lt; &#34;send non empty: &#34; &lt;&lt; seg.header().to_string() &lt;&lt; &#34;length:&#34; &lt;&lt; seg.length_in_sequence_space() &lt;&lt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// endl &lt;&lt; endl;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _segments_out.push(seg);
</span></span><span style="display:flex;"><span>    _segments_outstanding.push(seg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// [RFC6298]:(5.1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_timer.open()) {
</span></span><span style="display:flex;"><span>        _timer.start();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="lab4">lab4</h1>
<h2 id="示意图">示意图</h2>
<p><img src="https://github.com/Doraemonzzz/md-photo/blob/master/CS144/Lab/Lab4/6.jpg?raw=true" alt="img"></p>
<h1 id="参考资料">参考资料</h1>
<p>[1].<a href="http://arthurchiao.art/blog/rfc1180-a-tcp-ip-tutorial-zh/" target="_blank">译] RFC 1180：朴素 TCP/IP 教程（1991）</a>
</p>
<p>[2].<a href="https://kiprey.github.io/2021/05/cnatda-1/#%E7%AE%80%E4%BB%8B" target="_blank">计算机网络笔记-1</a>
</p>
<p>[3].<a href="https://zhuanlan.zhihu.com/p/101702312" target="_blank">详解 TCP 超时与重传机制</a>
</p>
<p>[4].<a href="https://github.com/huangrt01/TCP-Lab" target="_blank">Breadcrumbs/TCP-Lab</a>
（代码质量非常高，极具学习价值！）</p>
<p>[5].「<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6298" target="_blank">RFC6298</a>
」</p>
<p>[6].<a href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html" target="_blank">【计算机网络】Stanford CS144 Lab Assignments 学习笔记 </a>
</p>
<p>[7].<a href="https://doraemonzzz.com/tags/CS144/" target="_blank">CS144 Lab &amp; 翻译 - Doraemonzzz</a>
</p>
<p>[8].<a href="https://segmentfault.com/a/1190000039220243" target="_blank">CS144 Lab Assignments - 手写TCP - LAB4</a>
</p>

        
      </section>

      
      <div class="divider"></div>
      <div class="flex flex-col md:flex-row justify-between gap-4 py-4">
        
        <a class="group btn btn-outline" href="/past_posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%89%AF%E5%A5%BD%E7%9A%84%E7%BB%84%E7%BB%87%E5%A4%A7%E5%AD%A6%E5%90%91/" title="什么是良好的组织？（大学向）">
          <ion-icon name="chevron-back"></ion-icon>
          <div class="inline-flex flex-col items-start">
            <span class="text-base-content/60 group-hover:text-neutral-content/60 text-xs font-normal">上一页</span>
            <span class="max-w-48 truncate">什么是良好的组织？（大学向）</span>
          </div>
        </a>
        

        
        <a class="group btn btn-outline" href="/past_posts/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="树状数组">
          <div class="inline-flex flex-col items-end">
            <span class="text-base-content/60 group-hover:text-neutral-content/60 text-xs font-normal">下一页</span>
            <span class="max-w-48 truncate">树状数组</span>
          </div>
          <ion-icon name="chevron-forward"></ion-icon>
        </a>
        
      </div>
      

      
    </article>
  </div>

  <div class="hidden lg:flex lg:flex-col lg:items-end">
    
      <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#webgetcc">webget.cc</a></li>
        <li><a href="#byte_streamhh">byte_stream.hh</a></li>
        <li><a href="#byte_streamcc">byte_stream.cc</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#配置">配置</a></li>
    <li><a href="#实验结构">实验结构</a></li>
    <li><a href="#环境配置">环境配置</a></li>
    <li><a href="#接口">接口</a></li>
    <li><a href="#streamreassembler实现">StreamReassembler实现</a>
      <ul>
        <li><a href="#stream_reassemblerhh">stream_reassembler.hh</a></li>
        <li><a href="#stream_reassemblercc">stream_reassembler.cc</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#序列号转换">序列号转换</a></li>
    <li><a href="#tcpreceiver">TCPReceiver</a></li>
  </ul>

  <ul>
    <li><a href="#tcpsender">TCPsender</a>
      <ul>
        <li><a href="#1tcpsender-功能">1.TCPSender 功能</a></li>
        <li><a href="#2-如何检测丢包">2. 如何检测丢包</a></li>
        <li><a href="#代码">代码</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#示意图">示意图</a></li>
  </ul>
</nav>
    
  </div>
</div>


            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2022 - 2025 Ar-Gas&#39;blog
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'moon', status: 'y' },
    { name: 'sunny', status: 'n' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
        <div class="back">
          <div class="container">
            
            <div class="dream-grid dream-grid-about">
  
  
  
  <div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column">
    <article
      class="card card-compact bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"
    >
      <div class="card-body">
        <div class="card-title">作者简介</div>

        <div class="prose dark:prose-invert">
          <h3 id="hi-there-">Hi there 👋</h3>
<ul>
<li>🌱 I’m a junior software engineering student (2022-2026) in Taiyuan University of Technology.</li>
<li>👯 I’m working on computer programming compertation and server development and kernel development, interested in C++、 Rust.</li>
<li>🤔 I am also looking for help from like-minded friends.</li>
<li>📫 How to reach me: email me :2934060590@qq.com</li>
<li>⚡ I won a bronze medal 🥉 in the ICPC (ACM) Invitational tournament.</li>
</ul>
<h3 id="-实习经历-work-experience">🏢 实习经历 Work experience</h3>
<ul>
<li><a href="https://www.aispeech.com/" target="_blank">思必驰/aispeech</a>
 📌2024.07-2024.09
<ul>
<li>工作岗位：研发实习生</li>
<li>工作部门：智能汽车事业部</li>
<li>工作方向：摸鱼打杂小透明/doge</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </article>
  </div>
  
  

  

  
</div>

            

            
<footer class="flex justify-between items-center gap-2 px-4 py-12">

  <div>
  
  <p>
    © 2022 - 2025 Ar-Gas&#39;blog
  </p>
  

  
  <p class="text-sm">
    🌱
    <span class="text-base-content/60">
      Powered by <a class="hover:underline" href="https://gohugo.io/" target="_blank">Hugo</a> with theme
      <a class="hover:underline" href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</span
    >
  </p>
  
</div>

  <div
  x-data="{ icons: [
    { name: 'moon', status: 'y' },
    { name: 'sunny', status: 'n' },
    { name: 'desktop', status: 'auto' }
  ] }"
  class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"
>
  <template x-for="icon in icons">
    <div
      role="button"
      tabindex="0"
      :aria-label="'Select ' + icon.name + ' mode'"
      class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary"
      :class="$store.darkMode.icon() === icon.name && 'bg-primary'"
      @click="$store.darkMode.toggle(icon.status)"
    >
      <ion-icon
        :name="`${icon.name}-outline`"
        class="group-hover:text-primary-content"
        :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"
      >
      </ion-icon>
    </div>
  </template>
</div>

</footer>

          </div>
        </div>
      </div>
    </div>

    <script>
  window.lightTheme = "emerald"
  window.darkTheme = "forest"
</script>


  <script src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>

  
  
  <script src="/js/grid.js"></script>




<script src="/js/main.js"></script>

    


<script
  src="https://cdn.jsdelivr.net/npm/luxon@1.26.0"
  integrity="sha256-4sbTzmCCW9LGrIh5OsN8V5Pfdad1F1MwhLAOyXKnsE0="
  crossorigin="anonymous"
></script>
<script>
  format()

  function format() {
    document.querySelectorAll('span[data-format="luxon"]').forEach(el => {
      const date = el.textContent

      el.textContent = luxon.DateTime.fromISO(date, { locale: "zh" }).toFormat("yyyy年MM月dd日")
    })
  }
</script>






  
    <script type="module">
      import mediumZoom from 'https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/+esm';
      mediumZoom('#dream-single-post-content img', {
        background: 'oklch(var(--b1))',
        margin: 24,
      })
    </script>
  




    

    

    

    

    <script type="module" src="https://unpkg.com/ionicons@7.4.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.4.0/dist/ionicons/ionicons.js"></script>
  </body>
</html>
