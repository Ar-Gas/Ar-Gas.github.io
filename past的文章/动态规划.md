---
title: 动态规划
date: 2023-04-07 09:42:00
tags: [algrithm/算法]
categories: [学习笔记,算法]
mathjax: true
---
# 两个性质

1. **最优子结构**：问题的最优解由其子问题的最优解**组合而成**；且子问题可独立求解；
2. **重叠子问题**：子问题的算法相同。

# 步骤

1. 问题结构分析（数学语言描述）；

2. 递推关系建立；

3. 自底向上计算，确立计算顺序；

4. 最优方案追踪（记录数组回溯）

   <!--more-->

# 复杂度

复杂度取决于**子问题的个数**和**子问题的复杂度**。

# 类型

## 背包DP

[背包问题-knapsack problem](https://ar-gas.github.io/post/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-knapsack%20problem/)

## 线性DP

### 最长上升子序列  - LIS

递推关系：$F[i] =\max_{0 \le j < i, v[j] < v[i]}(F[j] + i)$

边界：$F[0] = 0$

### 最长公共子串 - LCS

递推关系：$F[i, j]=\max \left\{\begin{array}{l}
F[i-1, j] \\\\
F[i, j-1] \\\\
F[i-1, j-1]+1 \quad \text { if } A[i]=B[j]
\end{array}\right.$

边界：$F[0,] = F[,0] = 0$

#### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

#define N 100
#define max(a,b) (a)>(b)?(a):(b)

int dp[N][N]={0};//dp value

int main() {
    char t[N]="abcdefg",s[N]="abcdgaaabcdef";//input
    
    for(int i=0;i<strlen(s);i++)
        for(int j=0;j<strlen(t);j++)
          if(s[i]==t[j])dp[i+1][j+1]=dp[i][j]+1;//decrease-and-conquer
          else dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);//divide-and-conquer

    cout<<dp[strlen(s)][strlen(t)];//output
}
```

## 数组DP

## 区间DP

### 最小编辑距离

### 钢铁切割

### 矩阵链乘法

# 例题

[LCS例题题解]( https://ar-gas.github.io/post/背包问题-knapsack%20problem/ )

# 区别

- 与 分治：分治是独立的子问题
- 与 贪心：贪心自顶向下

# Reference

[1].[Dynamic Programming —— Geeksforgeeks](https://www.geeksforgeeks.org/dynamic-programming/?ref=lbp)

[2].[Introduction to algorithms](https://sd.blackball.lv/library/Introduction_to_Algorithms_Third_Edition_(2009).pdf)

[3].[算法设计与分析 - 北航童咏昕教授](https://www.bilibili.com/video/BV1aN411d7Yi?p=19&vd_source=a326e65c6d0fa8e7b1904a3c161ec105)