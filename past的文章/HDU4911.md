---
title: HDU 4911
date: 2023-12-25 15:50:00
tags: [题解]
categories: [题解,HDU]
mathjax: true
---

## 题解

在归并排序中加一行公式计算原序列逆序数

在合并过程中，如果a[i]大于a[j]，那么a[i]后面的元素也都大于a[j]，所以逆序对的数量就是从i到mid的元素的数量，即`mid - i + 1`。

## AC代码

```c++
#include <iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 100005;

int n;
long long k,ans;
int a[N],b[N];


void merge(int l, int mid, int r){
    int i = l, j = mid + 1;
    int idx = 0;
    while(i <= mid && j <= r){
        if(a[i] > a[j]){
            b[idx ++] = a[j ++];
            ans += mid - i + 1;
        }
        else b[idx ++] = a[i ++];
    }
    while(i <= mid )b[idx ++] = a[i ++];
    while(j <= r )b[idx ++] = a[j ++];
    for (int i = 0; i < idx; ++i)
    {
        a[l + i] = b[i];
    }
    return;
}

void merge_sort(int l, int r){
    int mid = (l + r) / 2;
    if(l >= r)return;
    else{
        merge_sort(l, mid);
        merge_sort(mid +1, r);
        merge(l, mid, r);
    }
    return;
}


int main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    while(cin >> n >> k){
        memset(b, 0, N);
        memset(a, 0, N);
        ans = 0;
        for (int i = 0; i < n; ++i)
        {
            cin >> a[i];
        }
        merge_sort(0, n - 1);
        cout << (ans - k > 0 ? (long long)(ans - k) : 0) << endl;
    }
    return 0;
}
```

