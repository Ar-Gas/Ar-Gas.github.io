---
title: 搜索
date: 2023-04-02 09:42:00
tags: [algrithm/算法]
categories: [学习笔记,算法]
mathjax: true
---
搜索基础

<!-- more -->

- **DFS**：
  - 数据结构：Stack (本质为递归)
  - 空间：树高
  - 不具最短性

- **BFS**：
  - 数据结构：queue
  - 空间：$$2^{树高}$$
  - 最短路

# Depth-first Search 深度优先搜索

```c++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

# Breadth-first Search 广度优先搜索

```c++
```



```c++
// 20231003回顾
// 这题虽然忘了是哪道题但是确实是BFS（
// 参考吧，AcWing模板在上面
#include <bits/stdc++.h>
using namespace std;

// 定义节点结构体
struct Node
{
    int x, y;
    int step;
    Node(int x, int y, int step) : x(x), y(y), step(step) {}//initializer list
};

const int N = 1010;
int n, m;
char g[N][N];
bool st[N][N]; // 用于记录每个节点是否被访问过
int dx[4] = {-1, 0, 1, 0}; // 四个方向
int dy[4] = {0, 1, 0, -1};

int bfs(int sx, int sy, int ex, int ey)
{
    queue<Node> q;
    q.push({sx, sy, 0});
    st[sx][sy] = true;

    while (!q.empty())
    {
        auto t = q.front();
        q.pop();

        if (t.x == ex && t.y == ey) // 找到终点
            return t.step;

        for (int i = 0; i < 4; i++) // 四个方向
        {
            int x = t.x + dx[i];
            int y = t.y + dy[i];

            if (x < 0 || x >= n || y < 0 || y >= m) // 判断越界
                continue;
            if (g[x][y] == '#' || st[x][y]) // 判断是否是障碍或已经访问过
                continue;

            q.push({x, y, t.step + 1});
            st[x][y] = true;
        }
    }

    return -1; // 没有找到路径
}

int main()
{
    cin >> n >> m;

    int sx, sy, ex, ey; // 起点和终点坐标

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> g[i][j];
            if (g[i][j] == 'S')
            {
                sx = i;
                sy = j;
            }
            if (g[i][j] == 'E')
            {
                ex = i;
                ey = j;
            }
        }
    }

    int res = bfs(sx, sy, ex, ey);
    cout << res << endl;

    return 0;
}
```

# 剪枝优化

常见的剪枝方法有三种：

-   记忆化搜索；
-   最优性剪枝；
-   可行性剪枝。



# 参考链接

[1].[Depth First Search or DFS for a Graph —— GeeksforGeeks](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)